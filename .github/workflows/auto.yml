name: Android Firmware Extraction and DT Generation

on:
  workflow_dispatch:
    inputs:
      LINK_GDRIVE:
        description: 'Google Drive link to firmware file'
        required: true
        type: string
      OUTPUT_DIR:
        description: 'Output directory name (optional)'
        required: false
        default: 'device_tree'
        type: string
      NO_PROPRIETARY:
        description: 'Skip proprietary files extraction'
        required: false
        default: false
        type: boolean
      PIXELDRAIN_ID:
        description: 'Pixeldrain ID (fallback if GDrive fails)'
        required: false
        type: string

jobs:
  extract-and-generate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            erofs-utils \
            android-sdk-libsparse-utils \
            p7zip-full \
            liblz4-tool \
            brotli \
            curl

      - name: Download and setup lpunpack.py
        run: |
          curl -L https://raw.githubusercontent.com/unix3dgforce/lpunpack/refs/heads/master/lpunpack.py -o /tmp/lpunpack.py
          chmod +x /tmp/lpunpack.py
          sudo ln -sf /tmp/lpunpack.py /usr/local/bin/lpunpack

      - name: Install Python packages
        run: |
          pip install aospdtgen dumpyara gdown google-auth google-auth-oauthlib requests

      - name: Extract File ID
        id: extract
        run: |
          GDRIVE_LINK="${{ github.event.inputs.LINK_GDRIVE }}"
          
          if [[ $GDRIVE_LINK =~ /file/d/([a-zA-Z0-9_-]+) ]]; then
            FILE_ID="${BASH_REMATCH[1]}"
          elif [[ $GDRIVE_LINK =~ id=([a-zA-Z0-9_-]+) ]]; then
            FILE_ID="${BASH_REMATCH[1]}"
          elif [[ $GDRIVE_LINK =~ /d/([a-zA-Z0-9_-]+) ]]; then
            FILE_ID="${BASH_REMATCH[1]}"
          else
            echo "Error: Could not extract file ID"
            exit 1
          fi
          
          echo "FILE_ID=$FILE_ID" >> $GITHUB_ENV
          echo "File ID: $FILE_ID"

      - name: Method 1 - Python Google Auth with Export
        id: method1
        continue-on-error: true
        run: |
          echo "=== Trying Method 1: Python Google Auth ==="
          
          python3 << 'PYEOF'
          import json
          import base64
          import requests
          import os
          import re
          from google.oauth2 import service_account
          from google.auth.transport.requests import Request
          
          sa_b64 = "${{ secrets.GDRIVE_SERVICE_ACCOUNT }}"
          file_id = "${{ env.FILE_ID }}"
          
          try:
              # Decode service account
              sa_json = base64.b64decode(sa_b64)
              sa_data = json.loads(sa_json)
              
              # Save temp
              with open('/tmp/sa.json', 'w') as f:
                  json.dump(sa_data, f)
              
              # Auth
              credentials = service_account.Credentials.from_service_account_info(
                  sa_data,
                  scopes=['https://www.googleapis.com/auth/drive.readonly']
              )
              credentials.refresh(Request())
              
              # Download dengan confirm token handling
              session = requests.Session()
              headers = {"Authorization": f"Bearer {credentials.token}"}
              
              # Step 1: Get confirm token
              url1 = f"https://drive.google.com/uc?id={file_id}&export=download"
              response1 = session.get(url1, headers=headers, stream=True, allow_redirects=True)
              
              # Check for virus scan warning
              confirm_token = None
              for key, value in response1.cookies.items():
                  if key.startswith("download_warning"):
                      confirm_token = value
                      break
              
              # Check HTML content for confirm
              if confirm_token is None and "confirm" in response1.text:
                  match = re.search(r'confirm=([0-9A-Za-z_-]+)', response1.text)
                  if match:
                      confirm_token = match.group(1)
              
              # Step 2: Download dengan confirm
              if confirm_token:
                  url2 = f"https://drive.google.com/uc?export=download&confirm={confirm_token}&id={file_id}"
                  response = session.get(url2, headers=headers, stream=True)
              else:
                  response = response1
              
              # Check content type
              content_type = response.headers.get('content-type', '')
              print(f"Content-Type: {content_type}")
              
              # Save
              total_size = 0
              with open("firmware.zip", "wb") as f:
                  for chunk in response.iter_content(chunk_size=8192):
                      if chunk:
                          f.write(chunk)
                          total_size += len(chunk)
              
              print(f"Downloaded: {total_size} bytes")
              
              # Verify not HTML error
              with open("firmware.zip", "rb") as f:
                  header = f.read(100)
                  if b"<html" in header or b"<!DOCTYPE" in header:
                      print("ERROR: Downloaded HTML error page")
                      exit(1)
              
              if total_size < 1000000:
                  print("ERROR: File too small")
                  exit(1)
                  
              print("SUCCESS: Method 1 worked")
              
          except Exception as e:
              print(f"FAILED: {e}")
              exit(1)
          PYEOF

      - name: Method 2 - Rclone with Service Account
        if: steps.method1.outcome == 'failure'
        id: method2
        continue-on-error: true
        run: |
          echo "=== Trying Method 2: Rclone ==="
          
          # Install rclone
          curl https://rclone.org/install.sh | sudo bash
          
          # Setup config
          mkdir -p ~/.config/rclone
          cat > ~/.config/rclone/rclone.conf << EOF
          [gdrive]
          type = drive
          scope = drive.readonly
          service_account_file = /tmp/sa.json
          EOF
          
          # Try download
          mkdir -p /tmp/gdrive
          rclone copy "gdrive:${{ env.FILE_ID }}" /tmp/gdrive -v --drive-export-formats "" --retries 3
          
          # Check result
          FILE=$(find /tmp/gdrive -type f -name "*" | head -1)
          if [ -f "$FILE" ]; then
              mv "$FILE" firmware.zip
              SIZE=$(stat -c%s firmware.zip)
              echo "Downloaded: $SIZE bytes"
              
              if [ "$SIZE" -gt 1000000 ]; then
                  echo "SUCCESS: Method 2 worked"
              else
                  echo "FAILED: File too small"
                  exit 1
              fi
          else
              echo "FAILED: No file downloaded"
              exit 1
          fi

      - name: Method 3 - Gdown with OAuth Token
        if: steps.method2.outcome == 'failure'
        id: method3
        continue-on-error: true
        run: |
          echo "=== Trying Method 3: Gdown with OAuth ==="
          
          # Generate token dari service account
          python3 << 'PYEOF'
          import json
          import base64
          from google.oauth2 import service_account
          from google.auth.transport.requests import Request
          
          sa_b64 = "${{ secrets.GDRIVE_SERVICE_ACCOUNT }}"
          sa_json = base64.b64decode(sa_b64)
          sa_data = json.loads(sa_json)
          
          credentials = service_account.Credentials.from_service_account_info(
              sa_data,
              scopes=['https://www.googleapis.com/auth/drive.readonly']
          )
          credentials.refresh(Request())
          
          with open('/tmp/token.txt', 'w') as f:
              f.write(credentials.token)
          PYEOF
          
          # Export token untuk gdown
          export GDRIVE_ACCESS_TOKEN=$(cat /tmp/token.txt)
          
          # Download dengan gdown
          gdown "${{ env.FILE_ID }}" -O firmware.zip --no-cookies --continue
          
          # Verify
          SIZE=$(stat -c%s firmware.zip 2>/dev/null || echo 0)
          echo "Downloaded: $SIZE bytes"
          
          if [ "$SIZE" -lt 1000000 ]; then
              echo "FAILED: File too small"
              exit 1
          fi
          
          echo "SUCCESS: Method 3 worked"

      - name: Method 4 - Pixeldrain Fallback
        if: steps.method3.outcome == 'failure'
        id: method4
        run: |
          echo "=== Trying Method 4: Pixeldrain ==="
          
          PD_ID="${{ github.event.inputs.PIXELDRAIN_ID }}"
          
          if [ -z "$PD_ID" ]; then
              echo "ERROR: No Pixeldrain ID provided"
              echo "All methods failed. Please provide PIXELDRAIN_ID input."
              exit 1
          fi
          
          curl -L "https://pixeldrain.com/api/file/${PD_ID}" \
            -o firmware.zip \
            --progress-bar \
            --retry 3 \
            --retry-delay 5
          
          SIZE=$(stat -c%s firmware.zip)
          echo "Downloaded: $SIZE bytes"
          
          if [ "$SIZE" -lt 1000000 ]; then
              echo "FAILED: Pixeldrain file too small"
              exit 1
          fi
          
          echo "SUCCESS: Method 4 worked"

      - name: Verify Final Download
        run: |
          if [ ! -f firmware.zip ]; then
              echo "ERROR: No firmware file found"
              exit 1
          fi
          
          SIZE=$(stat -c%s firmware.zip)
          echo "Final file size: $SIZE bytes"
          
          # Check not HTML
          if head -c 100 firmware.zip | grep -q "<html\|<!DOCTYPE"; then
              echo "ERROR: File is HTML, not binary"
              exit 1
          fi
          
          echo "FILENAME=firmware.zip" >> $GITHUB_ENV
          echo "Download verified successfully!"

      - name: Extract firmware with dumpyara
        run: |
          python3 -m dumpyara "${{ env.FILENAME }}" -o extracted_firmware -v

      - name: Generate device tree with aospdtgen
        run: |
          OUTPUT="${{ github.event.inputs.OUTPUT_DIR }}"
          
          if [ "${{ github.event.inputs.NO_PROPRIETARY }}" == "true" ]; then
            python -m aospdtgen --no-proprietary-files -o "$OUTPUT" extracted_firmware/
          else
            python -m aospdtgen -o "$OUTPUT" extracted_firmware/
          fi

      - name: Upload device tree artifact
        uses: actions/upload-artifact@v4
        with:
          name: device-tree-${{ github.run_number }}
          path: ${{ github.event.inputs.OUTPUT_DIR }}/
          retention-days: 3

      - name: Cleanup
        if: always()
        run: |
          rm -f firmware.zip 2>/dev/null || true
          rm -rf extracted_firmware /tmp/gdrive 2>/dev/null || true
          rm -f /tmp/lpunpack.py /tmp/sa.json /tmp/token.txt 2>/dev/null || true
